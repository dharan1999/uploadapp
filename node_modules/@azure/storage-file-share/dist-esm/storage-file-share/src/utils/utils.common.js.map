{"version":3,"file":"utils.common.js","sourceRoot":"","sources":["../../../../src/utils/utils.common.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { HttpHeaders, createHttpHeaders } from \"@azure/core-rest-pipeline\";\nimport {\n  ListFilesAndDirectoriesSegmentResponse as ListFilesAndDirectoriesSegmentResponseInternal,\n  ListHandlesResponse as ListHandlesResponseInternal,\n  SharePermission,\n  StringEncoded,\n} from \"../generated/src/models\";\nimport {\n  DirectoryItem,\n  FileItem,\n  HandleItem,\n  ListFilesAndDirectoriesSegmentResponse,\n  ListHandlesResponse,\n} from \"../generatedModels\";\nimport { HttpAuthorization } from \"../models\";\nimport { HeaderConstants, PathStylePorts, URLConstants } from \"./constants\";\nimport { isNode } from \"@azure/core-util\";\nimport { HttpHeadersLike, WebResourceLike } from \"@azure/core-http-compat\";\n\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XXXClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XXXClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" insead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `ContainerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\nexport function escapeURLPath(url: string): string {\n  const urlParsed = new URL(url);\n\n  let path = urlParsed.pathname;\n  path = path || \"/\";\n\n  path = escape(path);\n  urlParsed.pathname = path;\n\n  return urlParsed.toString();\n}\n\nexport interface ConnectionString {\n  kind: \"AccountConnString\" | \"SASConnString\";\n  url: string;\n  accountName: string;\n  accountKey?: any;\n  accountSas?: string;\n}\n\nfunction getValueInConnString(\n  connectionString: string,\n  argument:\n    | \"FileEndpoint\"\n    | \"AccountName\"\n    | \"AccountKey\"\n    | \"DefaultEndpointsProtocol\"\n    | \"EndpointSuffix\"\n    | \"SharedAccessSignature\",\n) {\n  const elements = connectionString.split(\";\");\n  for (const element of elements) {\n    if (element.trim().startsWith(argument)) {\n      return element.trim().match(argument + \"=(.*)\")![1];\n    }\n  }\n  return \"\";\n}\n\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\nexport function extractConnectionStringParts(connectionString: string): ConnectionString {\n  // Matching FileEndpoint in the Account connection string\n  let fileEndpoint = getValueInConnString(connectionString, \"FileEndpoint\");\n  // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n  fileEndpoint = fileEndpoint.endsWith(\"/\") ? fileEndpoint.slice(0, -1) : fileEndpoint;\n\n  if (\n    connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 &&\n    connectionString.search(\"AccountKey=\") !== -1\n  ) {\n    // Account connection string\n\n    let defaultEndpointsProtocol = \"\";\n    let accountName = \"\";\n    let accountKey = Buffer.from(\"accountKey\", \"base64\");\n    let endpointSuffix = \"\";\n\n    // Get account name and key\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n\n    if (!fileEndpoint) {\n      // FileEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`\n\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      const protocol = defaultEndpointsProtocol!.toLowerCase();\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\n          \"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\",\n        );\n      }\n\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n      fileEndpoint = `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`;\n    }\n\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n\n    return {\n      kind: \"AccountConnString\",\n      url: fileEndpoint,\n      accountName,\n      accountKey,\n    };\n  } else {\n    // SAS connection string\n    const accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    let accountName = getValueInConnString(connectionString, \"AccountName\");\n    // if accountName is empty, try to read it from BlobEndpoint\n    if (!accountName) {\n      accountName = getAccountNameFromUrl(fileEndpoint);\n    }\n    if (!fileEndpoint) {\n      throw new Error(\"Invalid FileEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n\n    return { kind: \"SASConnString\", url: fileEndpoint, accountName, accountSas };\n  }\n}\n\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\nfunction escape(text: string): string {\n  return encodeURIComponent(text)\n    .replace(/%2F/g, \"/\") // Don't escape for \"/\"\n    .replace(/'/g, \"%27\") // Escape for \"'\"\n    .replace(/\\+/g, \"%20\")\n    .replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\nexport function appendToURLPath(url: string, name: string): string {\n  const urlParsed = new URL(url);\n\n  let path = urlParsed.pathname;\n  path = path ? (path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}`) : name;\n  urlParsed.pathname = path;\n\n  return urlParsed.toString();\n}\n\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\nexport function appendToURLQuery(url: string, queryParts: string): string {\n  const urlParsed = new URL(url);\n\n  let query = urlParsed.search;\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n\n  urlParsed.search = query;\n  return urlParsed.toString();\n}\n\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\nexport function setURLParameter(url: string, name: string, value?: string): string {\n  const urlParsed = new URL(url);\n  const encodedName = encodeURIComponent(name);\n  const encodedValue = value ? encodeURIComponent(value) : undefined;\n  // mutating searchParams will change the encoding, so we have to do this ourselves\n  const searchString = urlParsed.search === \"\" ? \"?\" : urlParsed.search;\n\n  const searchPieces: string[] = [];\n\n  for (const pair of searchString.slice(1).split(\"&\")) {\n    if (pair) {\n      const [key] = pair.split(\"=\", 2);\n      if (key !== encodedName) {\n        searchPieces.push(pair);\n      }\n    }\n  }\n  if (encodedValue) {\n    searchPieces.push(`${encodedName}=${encodedValue}`);\n  }\n\n  urlParsed.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n\n  return urlParsed.toString();\n}\n\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\nexport function getURLParameter(url: string, name: string): string | string[] | undefined {\n  const urlParsed = new URL(url);\n  return urlParsed.searchParams.get(name) ?? undefined;\n}\n\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\nexport function setURLHost(url: string, host: string): string {\n  const urlParsed = new URL(url);\n  urlParsed.hostname = host;\n  return urlParsed.toString();\n}\n\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPath(url: string): string | undefined {\n  try {\n    const urlParsed = new URL(url);\n    return urlParsed.pathname;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\nexport function getURLQueries(url: string): { [key: string]: string } {\n  let queryString = new URL(url).search;\n  if (!queryString) {\n    return {};\n  }\n\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substring(1) : queryString;\n\n  let querySubStrings: string[] = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter((value: string) => {\n    const indexOfEqual = value.indexOf(\"=\");\n    const lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return (\n      indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1\n    );\n  });\n\n  const queries: { [key: string]: string } = {};\n  for (const querySubString of querySubStrings) {\n    const splitResults = querySubString.split(\"=\");\n    const key: string = splitResults[0];\n    const value: string = splitResults[1];\n    queries[key] = value;\n  }\n\n  return queries;\n}\n\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\nexport function truncatedISO8061Date(date: Date, withMilliseconds: boolean = true): string {\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  const dateString = date.toISOString();\n\n  return withMilliseconds\n    ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\"\n    : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n\n/**\n * Base64 encode.\n *\n * @param content -\n */\nexport function base64encode(content: string): string {\n  return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\nexport function base64decode(encodedString: string): string {\n  return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\nexport async function delay(\n  timeInMs: number,\n  aborter?: AbortSignalLike,\n  abortError?: Error,\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    /* eslint-disable-next-line prefer-const */\n    let timeout: any;\n\n    const abortHandler = () => {\n      if (timeout !== undefined) {\n        clearTimeout(timeout);\n      }\n      reject(abortError);\n    };\n\n    const resolveHandler = () => {\n      if (aborter !== undefined) {\n        aborter.removeEventListener(\"abort\", abortHandler);\n      }\n      resolve();\n    };\n\n    /* eslint-disable-next-line prefer-const */\n    timeout = setTimeout(resolveHandler, timeInMs);\n    if (aborter !== undefined) {\n      aborter.addEventListener(\"abort\", abortHandler);\n    }\n  });\n}\n\nexport function sanitizeURL(url: string): string {\n  let safeURL: string = url;\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n\n  return safeURL;\n}\n\nexport function sanitizeHeaders(originalHeader: HttpHeaders): HttpHeaders {\n  const headers: HttpHeaders = createHttpHeaders();\n  for (const [name, value] of originalHeader) {\n    if (name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n      headers.set(name, \"*****\");\n    } else if (name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n      headers.set(name, sanitizeURL(value));\n    } else {\n      headers.set(name, value);\n    }\n  }\n\n  return headers;\n}\n\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\nexport function getAccountNameFromUrl(url: string): string {\n  const parsedUrl = new URL(url);\n  let accountName;\n  try {\n    if (parsedUrl.hostname.split(\".\")[1] === \"file\") {\n      // `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`;\n      // Slicing off '/' at the end if exists\n      url = url.endsWith(\"/\") ? url.slice(0, -1) : url;\n\n      accountName = parsedUrl.hostname.split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.pathname.split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n    return accountName;\n  } catch (error: any) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\n\nexport function isIpEndpointStyle(parsedUrl: URL): boolean {\n  const host = parsedUrl.host;\n\n  // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port) or host.docker.internal, use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n  return (\n    /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(\n      host,\n    ) ||\n    (Boolean(parsedUrl.port) && PathStylePorts.includes(parsedUrl.port))\n  );\n}\n\nexport function getShareNameAndPathFromUrl(url: string): {\n  baseName: string;\n  shareName: string;\n  path: string;\n} {\n  //  URL may look like the following\n  // \"https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString\";\n  // \"https://myaccount.file.core.windows.net/myshare/mydirectory/file\";\n  // \"https://myaccount.file.core.windows.net/myshare/mydirectory?sasString\";\n  // \"https://myaccount.file.core.windows.net/myshare/mydirectory\";\n  // \"https://myaccount.file.core.windows.net/myshare?sasString\";\n  // \"https://myaccount.file.core.windows.net/myshare\";\n  // IPv4/IPv6 address hosts, Endpoints - `http://187.24.0.1:1000/devstoreaccount1/mydirectory/file`\n  // http://localhost:1000/devstoreaccount1/mydirectory/file\n  // mydirectory can consist of multiple directories - dir1/dir2/dir3\n\n  let shareName;\n  let path;\n  let baseName;\n\n  try {\n    const parsedUrl = new URL(url);\n    if (parsedUrl.hostname.split(\".\")[1] === \"file\") {\n      // \"https://myaccount.file.core.windows.net/myshare/mydirectory/file\";\n      // .getPath() -> /myshare/mydirectory/file\n      const pathComponents = parsedUrl.pathname.match(\"/([^/]*)(/(.*))?\");\n      shareName = pathComponents![1];\n      path = pathComponents![3];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://187.24.0.1:1000/devstoreaccount1/mydirectory/file\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:1000/devstoreaccount1/mydirectory/file\n      // .getPath() -> /devstoreaccount1/mydirectory/file\n      const pathComponents = parsedUrl.pathname.match(\"/([^/]*)/([^/]*)(/(.*))?\");\n      shareName = pathComponents![2];\n      path = pathComponents![4];\n    } else {\n      // \"https://customdomain.com/myshare/mydirectory/file\";\n      // .getPath() -> /myshare/mydirectory/file\n      const pathComponents = parsedUrl.pathname.match(\"/([^/]*)(/(.*))?\");\n      shareName = pathComponents![1];\n      path = pathComponents![3];\n    }\n\n    // decode the encoded shareName and filePath - to get all the special characters that might be present in it\n    shareName = decodeURIComponent(shareName);\n    path = decodeURIComponent(path);\n\n    // Cast to string is required as TypeScript cannot infer that split() always returns\n    // an array with length >= 1\n    baseName = path.split(\"/\").pop() as string;\n\n    if (!shareName) {\n      throw new Error(\"Provided shareName is invalid.\");\n    } else {\n      return { baseName, shareName, path };\n    }\n  } catch (error: any) {\n    throw new Error(\n      \"Unable to extract shareName and filePath/directoryPath with provided information.\",\n    );\n  }\n}\n\nexport function httpAuthorizationToString(\n  httpAuthorization?: HttpAuthorization,\n): string | undefined {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\n\n/**\n * Set URL path.\n *\n * @param url - URL to change path to.\n * @param path - Path to set into the URL.\n */\nexport function setURLPath(url: string, path: string): string {\n  const urlParsed = new URL(url);\n  urlParsed.pathname = path;\n  return urlParsed.toString();\n}\n\n/**\n * Set URL query string.\n *\n * @param url - URL to set query string to.\n * @param queryString - Query string to set to the URL.\n */\nexport function setURLQueries(url: string, queryString: string): string {\n  const urlParsed = new URL(url);\n  urlParsed.search = queryString;\n  return urlParsed.toString();\n}\n\n/**\n * Escape the file or directory name but keep path separator ('/').\n */\nexport function EscapePath(pathName: string): string {\n  const split = pathName.split(\"/\");\n  for (let i = 0; i < split.length; i++) {\n    split[i] = encodeURIComponent(split[i]);\n  }\n  return split.join(\"/\");\n}\n\n/**\n * A representation of an HTTP response that\n * includes a reference to the request that\n * originated it.\n */\nexport interface HttpResponse {\n  /**\n   * The headers from the response.\n   */\n  headers: HttpHeadersLike;\n  /**\n   * The original request that resulted in this response.\n   */\n  request: WebResourceLike;\n  /**\n   * The HTTP status code returned from the service.\n   */\n  status: number;\n}\n\n/**\n * An object with a _response property that has\n * headers already parsed into a typed object.\n */\nexport interface ResponseWithHeaders<Headers> {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse & {\n    /**\n     * The parsed HTTP response headers.\n     */\n    parsedHeaders: Headers;\n  };\n}\n\n/**\n * An object with a _response property that has body\n * and headers already parsed into known types.\n */\nexport interface ResponseWithBody<Headers, Body> {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse & {\n    /**\n     * The parsed HTTP response headers.\n     */\n    parsedHeaders: Headers;\n    /**\n     * The response body as text (string format)\n     */\n    bodyAsText: string;\n    /**\n     * The response body as parsed JSON or XML\n     */\n    parsedBody: Body;\n  };\n}\n\n/**\n * An object with a simple _response property.\n */\nexport interface ResponseLike {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse;\n}\n\n/**\n * A type that represents an operation result with a known _response property.\n */\nexport type WithResponse<T, Headers = undefined, Body = undefined> = T &\n  (Body extends object\n    ? ResponseWithBody<Headers, Body>\n    : Headers extends object\n      ? ResponseWithHeaders<Headers>\n      : ResponseLike);\n\n/**\n * A typesafe helper for ensuring that a given response object has\n * the original _response attached.\n * @param response - A response object from calling a client operation\n * @returns The same object, but with known _response property\n */\nexport function assertResponse<T extends object, Headers = undefined, Body = undefined>(\n  response: T,\n): WithResponse<T, Headers, Body> {\n  if (`_response` in response) {\n    return response as WithResponse<T, Headers, Body>;\n  }\n\n  throw new TypeError(`Unexpected response object ${response}`);\n}\n\nexport function StringEncodedToString(name: StringEncoded): string {\n  if (name.encoded) {\n    return decodeURIComponent(name.content!);\n  } else {\n    return name.content!;\n  }\n}\n\nexport function ConvertInternalResponseOfListFiles(\n  internalResponse: ListFilesAndDirectoriesSegmentResponseInternal,\n): ListFilesAndDirectoriesSegmentResponse {\n  const wrappedResponse = {\n    ...internalResponse,\n    prefix: undefined,\n    directoryPath: StringEncodedToString({\n      encoded: internalResponse.encoded,\n      content: internalResponse.directoryPath,\n    }),\n    segment: {\n      fileItems: internalResponse.segment.fileItems.map((fileItemInternal) => {\n        const fileItem: FileItem = {\n          ...fileItemInternal,\n          name: StringEncodedToString(fileItemInternal.name),\n        };\n        return fileItem;\n      }),\n      directoryItems: internalResponse.segment.directoryItems.map((directoryItemInternal) => {\n        const directoryItem: DirectoryItem = {\n          ...directoryItemInternal,\n          name: StringEncodedToString(directoryItemInternal.name),\n        };\n        return directoryItem;\n      }),\n    },\n  };\n\n  delete wrappedResponse.encoded;\n\n  const listResponse: ListFilesAndDirectoriesSegmentResponse = wrappedResponse as any;\n\n  if (internalResponse.prefix) {\n    listResponse.prefix = StringEncodedToString(internalResponse.prefix);\n  }\n\n  return listResponse;\n}\n\nexport function ConvertInternalResponseOfListHandles(\n  internalResponse: ListHandlesResponseInternal,\n): ListHandlesResponse {\n  const wrappedResponse: ListHandlesResponse = {\n    ...internalResponse,\n    handleList: internalResponse.handleList\n      ? internalResponse.handleList.map((handleItemInternal) => {\n          const handleItem: HandleItem = {\n            ...handleItemInternal,\n            path: StringEncodedToString(handleItemInternal.path),\n          };\n          return handleItem;\n        })\n      : undefined,\n  };\n\n  return wrappedResponse;\n}\n\n/**\n * A small helper to handle converting an empty string \"\" into undefined\n * This is used in the case of query parameters (like continuation token) where\n * we don't want to send an empty query parameter to the service since the signing\n * policy for shared key will fail.\n * @internal\n */\nexport function removeEmptyString(value: string | undefined): string | undefined {\n  return value ? value : undefined;\n}\n\nexport function asSharePermission(value: string | SharePermission): SharePermission {\n  const castSharePermission = value as SharePermission;\n  if (castSharePermission[\"permission\"] !== undefined) {\n    return {\n      permission: castSharePermission.permission,\n      format: castSharePermission.format,\n    };\n  }\n\n  return {\n    permission: value as string,\n  };\n}\n"]}